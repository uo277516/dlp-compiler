@startuml Expressions
skinparam style strictuml
skinparam monochrome true


interface ASTNode {
    getLine(): int
    getColumn(): int
}



interface Expression

class AbstractExpression {
    line: int
    column: int
}

Expression <|-- AbstractExpression
ASTNode <|--  Expression

class IntLiteral {
    value: int
}

class RealLiteral {
    value: double
}

class charLiteral {
    value: char
}

class Variable {
    name: String
}

class Invocation {
    name: Variable
    params: List<Expression>
}

class ArrayAccess {
    index: Expression
    array: Expression

}




class FileAccess {
    field: String
    expression: Expression
}



class Cast{
    typeToCast: Type
    expression: Expression
}

class UnaryMinus {
    expression: Expression
}

class UnaryNot {
    expression: Expression
}

class Arithmetic {
    operator: String
    right: Expression
    left: Expression
}

class ArithmeticMultiply {
    operator: String
    right: Expression
    left: Expression
}

class Logical {
    operator: String
    right: Expression
    left: Expression

}

class Comparator {
    right: Expression
    left: Expression
    operator: String
}


Invocation o-- "0..n" AbstractExpression
ArrayAccess o-- "2" AbstractExpression
FileAccess o-- "1" AbstractExpression
Cast o-- "1" AbstractExpression
UnaryMinus o-- "1" AbstractExpression
UnaryNot o-- "1" AbstractExpression
Arithmetic o-- "2" AbstractExpression
ArithmeticMultiply o-- "2" AbstractExpression
Logical o-- "2" AbstractExpression
Comparator o-- "2" AbstractExpression

AbstractExpression <|-- Invocation



AbstractExpression <|-- IntLiteral
AbstractExpression <|-- RealLiteral
AbstractExpression <|-- charLiteral
AbstractExpression <|-- Variable
AbstractExpression <|-- Cast
AbstractExpression <|-- UnaryMinus
AbstractExpression <|-- UnaryNot

AbstractExpression <|-- FileAccess
AbstractExpression <|-- Arithmetic
AbstractExpression <|-- Logical

AbstractExpression <|-- Comparator

AbstractExpression <|-- ArrayAccess
AbstractExpression <|-- ArithmeticMultiply






class AbstractDefinition {
    line: int
    column: int
}


interface Statement
interface Definition

Definition <|.. AbstractDefinition

class VarDef {
    variable: Variable
    type: Type
}

class FunDef {
    body:List<Statement>
    localVars:List<VarDef>
    name: String
    type: FunType
}

class FuncType {
    params:List<VarDef>
    returnType: Type
}


FunDef o-- "0..n" Statement
Type <|.. FuncType

interface Type



class Program {
    funDefs: List<Definitions>
    varDefs: List<VarDef>
    line: int
    column: int
}

ASTNode <|.. Program
Program  o-- "0..n" Definition
ASTNode <|-- Definition

AbstractDefinition <|-- VarDef
AbstractDefinition <|-- FunDef
FunDef o-- "0..n" VarDef
VarDef o-- "1" Type







interface Statement

class Write {
    expression: List<Expression>
}

class Read {
    expression: List<Expression>
}

class If {
     condiciones: List<Expression>
        ifExps: List<Expression>
        ifSts: List<Statemment>
        elseExps: List<Expression>
        elseSts: List<Statemment>
}

class Return {
    expression: Expression
}

class While {
    condition: Expression
    whileSts: List<Statement>
    whileExps: List<Expression>
}

class AbstractStatement {
    line: int
    column: int
}

class Assignment {
    left: Expression
    right: Expression
}


Statement <|.. AbstractStatement


ASTNode <|-- Statement
AbstractStatement <|.. If
AbstractStatement <|.. Write
AbstractStatement <|.. Return
AbstractStatement <|.. While
AbstractStatement <|.. Read


If o-- "0..n" Expression
If o-- "0..n" AbstractStatement

While o-- "0..n" Expression
While o-- "0..n" AbstractStatement

Write o-- "0..n" Expression
Read o-- "0..n" Expression

Return o-- "1" Expression


AbstractStatement <|.. Assignment
Assignment o-- "2" Expression




interface Type

class AbstractType {
    line: int
    column: int
}

ASTNode <|.. Type

ArrayType o-- "1" AbstractType
StructType o-- "0..n" RecordField

class ArrayType {
    type: Type
}
class StructType {
    defs: List<RecordField>
}

class IntType
class RealType
class CharType
class VoidType
class FuncType {
    params:List<VarDef>
    returnType: Type
}

Type <|-- AbstractType

AbstractType <|-- ArrayType
AbstractType <|-- StructType
AbstractType <|-- FuncType

AbstractType <|-- IntType
AbstractType <|-- RealType
AbstractType <|-- CharType
AbstractType <|-- VoidType


@enduml
